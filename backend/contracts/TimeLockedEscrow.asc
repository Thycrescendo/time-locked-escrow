import { Address, Context, Storage, generateEvent, call, transferCoins } from '@massalabs/as/assembly';
import { u64 } from 'as-types';

interface Escrow {
  seller: Address;
  buyer: Address;
  asset: string; // JSON string for asset details (e.g., token, NFT)
  payment: u64;
  expiry: u64;
  status: string; // "Pending", "Completed", "Disputed", "Released", "Refunded"
  disputeLog: string[];
  penaltyRate: u64; // Percentage * 100 (e.g., 500 for 5%)
}

export class TimeLockedEscrow {
  private static readonly BASE_PENALTY: u64 = 500; // 5%
  private static readonly SCALING_CONSTANT: u64 = 100;
  private static readonly BASE_GAS_PRICE: u64 = 1000000; // Example base gas price

  // Create escrow and lock funds
  @export
  static createEscrow(id: string, buyer: string, seller: string, asset: string, payment: u64, expiry: u64): void {
    const buyerAddr = new Address(buyer);
    const sellerAddr = new Address(seller);
    const caller = Context.caller();

    // Verify caller has sufficient balance
    assert(Context.balance(caller) >= payment, 'Insufficient funds');
    transferCoins(caller, Context.callee(), payment); // Lock payment in contract

    // Store escrow
    const escrow: Escrow = {
      seller: sellerAddr,
      buyer: buyerAddr,
      asset,
      payment,
      expiry,
      status: 'Pending',
      disputeLog: [],
      penaltyRate: TimeLockedEscrow.BASE_PENALTY,
    };
    Storage.set(id, JSON.stringify(escrow));

    // Schedule auto-release
    Context.scheduleCall(Context.callee(), 'autoRelease', [id], expiry);

    // Emit DeWeb event
    generateEvent(`EscrowCreated|${id}|${asset}|${payment}|${expiry}`);
  }

  // Calculate dynamic penalty based on network congestion
  private static calculateDynamicPenalty(): u64 {
    const gasPrice = Context.currentGasPrice(); // Massa API for gas price
    const congestionFactor = gasPrice / TimeLockedEscrow.BASE_GAS_PRICE;
    return TimeLockedEscrow.BASE_PENALTY + congestionFactor * TimeLockedEscrow.SCALING_CONSTANT;
  }

  // Auto-release funds after expiry
  @export
  static autoRelease(id: string): void {
    const escrowStr = Storage.get(id);
    assert(escrowStr, 'Escrow not found');
    let escrow: Escrow = JSON.parse(escrowStr);

    assert(escrow.status == 'Pending', 'Invalid status');
    escrow.penaltyRate = TimeLockedEscrow.calculateDynamicPenalty();
    const penalty = (escrow.payment * escrow.penaltyRate) / 10000;
    const payout = escrow.payment - penalty;

    // Transfer funds
    transferCoins(Context.callee(), escrow.seller, payout);
    transferCoins(Context.callee(), escrow.buyer, penalty); // Penalty to buyer
    escrow.status = 'Released';
    Storage.set(id, JSON.stringify(escrow));

    // Emit DeWeb event
    generateEvent(`EscrowReleased|${id}|${payout}|${penalty}`);
  }

  // Initiate dispute
  @export
  static initiateDispute(id: string, message: string): void {
    const escrowStr = Storage.get(id);
    assert(escrowStr, 'Escrow not found');
    let escrow: Escrow = JSON.parse(escrowStr);
    const caller = Context.caller();

    assert(caller.equals(escrow.buyer) || caller.equals(escrow.seller), 'Unauthorized');
    assert(escrow.status == 'Pending', 'Invalid status');

    escrow.status = 'Disputed';
    escrow.disputeLog.push(`${caller.toString()}: ${message}`);
    Storage.set(id, JSON.stringify(escrow));

    // Schedule dispute resolution deadline
    Context.scheduleCall(Context.callee(), 'checkDispute', [id], Context.currentTimestamp() + 24 * 3600);

    // Emit DeWeb event
    generateEvent(`DisputeStarted|${id}|${message}`);
  }

  // Mutual agreement to release
  @export
  static agreeToRelease(id: string): void {
    const escrowStr = Storage.get(id);
    assert(escrowStr, 'Escrow not found');
    let escrow: Escrow = JSON.parse(escrowStr);
    const caller = Context.caller();

    assert(caller.equals(escrow.buyer) || caller.equals(escrow.seller), 'Unauthorized');
    assert(escrow.status == 'Pending' || escrow.status == 'Disputed', 'Invalid status');

    // Simplified: Assume second call confirms agreement
    transferCoins(Context.callee(), escrow.seller, escrow.payment);
    escrow.status = 'Completed';
    Storage.set(id, JSON.stringify(escrow));

    // Emit DeWeb event
    generateEvent(`EscrowCompleted|${id}`);
  }

  // Check dispute resolution
  @export
  static checkDispute(id: string): void {
    const escrowStr = Storage.get(id);
    assert(escrowStr, 'Escrow not found');
    let escrow: Escrow = JSON.parse(escrowStr);

    assert(escrow.status == 'Disputed', 'Invalid status');

    // If dispute unresolved, refund buyer
    transferCoins(Context.callee(), escrow.buyer, escrow.payment);
    escrow.status = 'Refunded';
    Storage.set(id, JSON.stringify(escrow));

    // Emit DeWeb event
    generateEvent(`EscrowRefunded|${id}`);
  }

  // Get escrow details
  @export
  static getEscrow(id: string): string {
    const escrowStr = Storage.get(id);
    assert(escrowStr, 'Escrow not found');
    return escrowStr;
  }
}